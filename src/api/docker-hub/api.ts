/* tslint:disable */
/* eslint-disable */
/**
 * Docker HUB API
 * Docker Hub is a service provided by Docker for finding and sharing container images with your team.  It is the world\'s largest library and community for container images.  In addition to the [Docker Hub UI](https://docs.docker.com/docker-hub/) and [Docker Hub CLI tool](https://github.com/docker/hub-tool#readme) (currently experimental),  Docker provides an API that allows you to interact with Docker Hub.  Browse through the Docker Hub API documentation to explore the supported endpoints. 
 *
 * The version of the OpenAPI document: beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'creator_ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'creator_ua'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'last_used'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'generated_by'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessToken
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'token_label'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessToken
     */
    'scopes'?: Array<string>;
}
/**
 * Audit log event.
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'actor'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AuditLog
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'action_description'?: string;
}
/**
 * Audit Log action
 * @export
 * @interface AuditLogAction
 */
export interface AuditLogAction {
    /**
     * Name of audit log action.
     * @type {string}
     * @memberof AuditLogAction
     */
    'name'?: string;
    /**
     * Description of audit log action.
     * @type {string}
     * @memberof AuditLogAction
     */
    'description'?: string;
    /**
     * Label for audit log action.
     * @type {string}
     * @memberof AuditLogAction
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface AuditLogActions
 */
export interface AuditLogActions {
    /**
     * List of audit log actions.
     * @type {Array<AuditLogAction>}
     * @memberof AuditLogActions
     */
    'actions'?: Array<AuditLogAction>;
    /**
     * Grouping label for a particular set of audit log actions.
     * @type {string}
     * @memberof AuditLogActions
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface CreateAccessTokenRequest
 */
export interface CreateAccessTokenRequest {
    /**
     * Friendly name for you to identify the token.
     * @type {string}
     * @memberof CreateAccessTokenRequest
     */
    'token_label': string;
    /**
     * Valid scopes: \"repo:admin\", \"repo:write\", \"repo:read\", \"repo:public_read\" 
     * @type {Array<string>}
     * @memberof CreateAccessTokenRequest
     */
    'scopes': Array<string>;
}
/**
 * Error with a detail field.
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * The error message.
     * @type {string}
     * @memberof ErrorDetail
     */
    'detail'?: string;
}
/**
 * Context information for an error used for diagnostics.
 * @export
 * @interface ErrorInfo
 */
export interface ErrorInfo {
    /**
     * ID of docker user.
     * @type {string}
     * @memberof ErrorInfo
     */
    'api_call_docker_id'?: string;
    /**
     * Name of the API operation called.
     * @type {string}
     * @memberof ErrorInfo
     */
    'api_call_name'?: string;
    /**
     * Date/time of call start.
     * @type {string}
     * @memberof ErrorInfo
     */
    'api_call_start'?: string;
    /**
     * Unique ID for this call.
     * @type {string}
     * @memberof ErrorInfo
     */
    'api_call_txnid'?: string;
}
/**
 * Represents an error.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Unique ID for this call.
     * @type {string}
     * @memberof ErrorResponse
     */
    'txnid'?: string;
    /**
     * The error message.
     * @type {string}
     * @memberof ErrorResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ErrorInfo}
     * @memberof ErrorResponse
     */
    'errinfo'?: ErrorInfo;
}
/**
 * 
 * @export
 * @interface GetAccessTokensResponse
 */
export interface GetAccessTokensResponse {
    /**
     * 
     * @type {number}
     * @memberof GetAccessTokensResponse
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokensResponse
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokensResponse
     */
    'previous'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetAccessTokensResponse
     */
    'active_count'?: number;
    /**
     * 
     * @type {Array<V2AccessTokensUuidGet200Response>}
     * @memberof GetAccessTokensResponse
     */
    'results'?: Array<V2AccessTokensUuidGet200Response>;
}
/**
 * GetAuditActions response.
 * @export
 * @interface GetAuditActionsResponse
 */
export interface GetAuditActionsResponse {
    /**
     * Map of audit log actions.
     * @type {{ [key: string]: AuditLogActions; }}
     * @memberof GetAuditActionsResponse
     */
    'actions'?: { [key: string]: AuditLogActions; };
}
/**
 * GetAuditLogs response.
 * @export
 * @interface GetAuditLogsResponse
 */
export interface GetAuditLogsResponse {
    /**
     * List of audit log events.
     * @type {Array<AuditLog>}
     * @memberof GetAuditLogsResponse
     */
    'logs'?: Array<AuditLog>;
}
/**
 * Paginated list of images in a repository.
 * @export
 * @interface GetNamespaceRepositoryImagesResponse
 */
export interface GetNamespaceRepositoryImagesResponse {
    /**
     * Total count of images in the repository.
     * @type {number}
     * @memberof GetNamespaceRepositoryImagesResponse
     */
    'count'?: number;
    /**
     * Link to the next page with the same query parameters if there are more images.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesResponse
     */
    'next'?: string | null;
    /**
     * Link to the previous page with the same query parameters if not on first page.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesResponse
     */
    'previous'?: string | null;
    /**
     * Image details.
     * @type {Array<GetNamespaceRepositoryImagesResponseResultsInner>}
     * @memberof GetNamespaceRepositoryImagesResponse
     */
    'results'?: Array<GetNamespaceRepositoryImagesResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetNamespaceRepositoryImagesResponseResultsInner
 */
export interface GetNamespaceRepositoryImagesResponseResultsInner {
    /**
     * The repository namespace.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesResponseResultsInner
     */
    'namespace'?: string;
    /**
     * The repository name.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesResponseResultsInner
     */
    'repository'?: string;
    /**
     * The image\'s digest.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesResponseResultsInner
     */
    'digest'?: string;
    /**
     * The current and historical tags for this image.
     * @type {Array<GetNamespaceRepositoryImagesResponseResultsInnerTagsInner>}
     * @memberof GetNamespaceRepositoryImagesResponseResultsInner
     */
    'tags'?: Array<GetNamespaceRepositoryImagesResponseResultsInnerTagsInner>;
    /**
     * Time when this image was last pushed.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesResponseResultsInner
     */
    'last_pushed'?: string | null;
    /**
     * Time when this image was last pulled. Note this is updated at most once per hour.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesResponseResultsInner
     */
    'last_pulled'?: string | null;
    /**
     * The status of the image based on its last activity against the `active_from` time.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesResponseResultsInner
     */
    'status'?: GetNamespaceRepositoryImagesResponseResultsInnerStatusEnum;
}

export const GetNamespaceRepositoryImagesResponseResultsInnerStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type GetNamespaceRepositoryImagesResponseResultsInnerStatusEnum = typeof GetNamespaceRepositoryImagesResponseResultsInnerStatusEnum[keyof typeof GetNamespaceRepositoryImagesResponseResultsInnerStatusEnum];

/**
 * 
 * @export
 * @interface GetNamespaceRepositoryImagesResponseResultsInnerTagsInner
 */
export interface GetNamespaceRepositoryImagesResponseResultsInnerTagsInner {
    /**
     * The tag.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesResponseResultsInnerTagsInner
     */
    'tag'?: string;
    /**
     * `true` if the tag currently points to this image.  `false` if it has been overwritten to point at a different image. 
     * @type {boolean}
     * @memberof GetNamespaceRepositoryImagesResponseResultsInnerTagsInner
     */
    'is_current'?: boolean;
}
/**
 * Summary information for images in a repository.
 * @export
 * @interface GetNamespaceRepositoryImagesSummaryResponse
 */
export interface GetNamespaceRepositoryImagesSummaryResponse {
    /**
     * Time from which an image must have been pushed or pulled to be counted as active.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesSummaryResponse
     */
    'active_from'?: string;
    /**
     * 
     * @type {GetNamespaceRepositoryImagesSummaryResponseStatistics}
     * @memberof GetNamespaceRepositoryImagesSummaryResponse
     */
    'statistics'?: GetNamespaceRepositoryImagesSummaryResponseStatistics;
}
/**
 * 
 * @export
 * @interface GetNamespaceRepositoryImagesSummaryResponseStatistics
 */
export interface GetNamespaceRepositoryImagesSummaryResponseStatistics {
    /**
     * Number of images in this repository.
     * @type {number}
     * @memberof GetNamespaceRepositoryImagesSummaryResponseStatistics
     */
    'total'?: number;
    /**
     * Number of images counted as active in this repository.
     * @type {number}
     * @memberof GetNamespaceRepositoryImagesSummaryResponseStatistics
     */
    'active'?: number;
    /**
     * Number of images counted as inactive in this repository.
     * @type {number}
     * @memberof GetNamespaceRepositoryImagesSummaryResponseStatistics
     */
    'inactive'?: number;
}
/**
 * Paginated list of tags for this repository.
 * @export
 * @interface GetNamespaceRepositoryImagesTagsResponse
 */
export interface GetNamespaceRepositoryImagesTagsResponse {
    /**
     * Total count of tags for this image.
     * @type {number}
     * @memberof GetNamespaceRepositoryImagesTagsResponse
     */
    'count'?: number;
    /**
     * Link to the next page if there are more tags.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesTagsResponse
     */
    'next'?: string | null;
    /**
     * Link to the previous page if not on first page.
     * @type {string}
     * @memberof GetNamespaceRepositoryImagesTagsResponse
     */
    'previous'?: string | null;
    /**
     * The current and historical tags for this image.
     * @type {Array<GetNamespaceRepositoryImagesResponseResultsInnerTagsInner>}
     * @memberof GetNamespaceRepositoryImagesTagsResponse
     */
    'results'?: Array<GetNamespaceRepositoryImagesResponseResultsInnerTagsInner>;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * CPU architecture
     * @type {string}
     * @memberof Image
     */
    'architecture'?: string;
    /**
     * CPU features
     * @type {string}
     * @memberof Image
     */
    'features'?: string;
    /**
     * CPU variant
     * @type {string}
     * @memberof Image
     */
    'variant'?: string;
    /**
     * image digest
     * @type {string}
     * @memberof Image
     */
    'digest'?: string | null;
    /**
     * 
     * @type {Array<Layer>}
     * @memberof Image
     */
    'layers'?: Array<Layer>;
    /**
     * operating system
     * @type {string}
     * @memberof Image
     */
    'os'?: string;
    /**
     * OS features
     * @type {string}
     * @memberof Image
     */
    'os_features'?: string;
    /**
     * OS version
     * @type {string}
     * @memberof Image
     */
    'os_version'?: string;
    /**
     * size of the image
     * @type {number}
     * @memberof Image
     */
    'size'?: number;
    /**
     * Status of the image
     * @type {string}
     * @memberof Image
     */
    'status'?: ImageStatusEnum;
    /**
     * datetime of last pull
     * @type {string}
     * @memberof Image
     */
    'last_pulled'?: string | null;
    /**
     * datetime of last push
     * @type {string}
     * @memberof Image
     */
    'last_pushed'?: string | null;
}

export const ImageStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type ImageStatusEnum = typeof ImageStatusEnum[keyof typeof ImageStatusEnum];

/**
 * 
 * @export
 * @interface Layer
 */
export interface Layer {
    /**
     * image layer digest
     * @type {string}
     * @memberof Layer
     */
    'digest'?: string | null;
    /**
     * size of the layer
     * @type {number}
     * @memberof Layer
     */
    'size'?: number;
    /**
     * Dockerfile instruction
     * @type {string}
     * @memberof Layer
     */
    'instruction'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface OrgSettings
 */
export interface OrgSettings {
    /**
     * 
     * @type {RestrictedImages}
     * @memberof OrgSettings
     */
    'restricted_images'?: RestrictedImages;
}
/**
 * 
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * total number of results available across all pages
     * @type {number}
     * @memberof Page
     */
    'count'?: number;
    /**
     * link to next page of results if any
     * @type {string}
     * @memberof Page
     */
    'next'?: string | null;
    /**
     * link to previous page of results  if any
     * @type {string}
     * @memberof Page
     */
    'previous'?: string | null;
}
/**
 * 
 * @export
 * @interface PaginatedTags
 */
export interface PaginatedTags {
    /**
     * total number of results available across all pages
     * @type {number}
     * @memberof PaginatedTags
     */
    'count'?: number;
    /**
     * link to next page of results if any
     * @type {string}
     * @memberof PaginatedTags
     */
    'next'?: string | null;
    /**
     * link to previous page of results  if any
     * @type {string}
     * @memberof PaginatedTags
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof PaginatedTags
     */
    'results'?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface PatchAccessTokenRequest
 */
export interface PatchAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccessTokenRequest
     */
    'token_label'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchAccessTokenRequest
     */
    'is_active'?: boolean;
}
/**
 * Delete images request.
 * @export
 * @interface PostNamespacesDeleteImagesRequest
 */
export interface PostNamespacesDeleteImagesRequest {
    /**
     * If `true` then will check and return errors and unignored warnings for the deletion request but will not delete any images.
     * @type {boolean}
     * @memberof PostNamespacesDeleteImagesRequest
     */
    'dry_run'?: boolean;
    /**
     * Sets the time from which an image must have been pushed or pulled to be counted as active.  Defaults to 1 month before the current time. 
     * @type {string}
     * @memberof PostNamespacesDeleteImagesRequest
     */
    'active_from'?: string;
    /**
     * Image manifests to delete.
     * @type {Array<PostNamespacesDeleteImagesRequestManifestsInner>}
     * @memberof PostNamespacesDeleteImagesRequest
     */
    'manifests'?: Array<PostNamespacesDeleteImagesRequestManifestsInner>;
    /**
     * Warnings to ignore. If a warning is not ignored then no deletions will happen and the  warning is returned in the response.  These warnings include:  - is_active: warning when attempting to delete an image that is marked as active. - current_tag: warning when attempting to delete an image that has one or more current  tags in the repository.  Warnings can be copied from the response to the request. 
     * @type {Array<PostNamespacesDeleteImagesRequestIgnoreWarningsInner>}
     * @memberof PostNamespacesDeleteImagesRequest
     */
    'ignore_warnings'?: Array<PostNamespacesDeleteImagesRequestIgnoreWarningsInner>;
}
/**
 * 
 * @export
 * @interface PostNamespacesDeleteImagesRequestIgnoreWarningsInner
 */
export interface PostNamespacesDeleteImagesRequestIgnoreWarningsInner {
    /**
     * Name of the repository of the image to ignore the warning for.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesRequestIgnoreWarningsInner
     */
    'repository': string;
    /**
     * Digest of the image to ignore the warning for.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesRequestIgnoreWarningsInner
     */
    'digest': string;
    /**
     * Warning to ignore.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesRequestIgnoreWarningsInner
     */
    'warning': PostNamespacesDeleteImagesRequestIgnoreWarningsInnerWarningEnum;
    /**
     * Current tags to ignore.
     * @type {Array<string>}
     * @memberof PostNamespacesDeleteImagesRequestIgnoreWarningsInner
     */
    'tags'?: Array<string>;
}

export const PostNamespacesDeleteImagesRequestIgnoreWarningsInnerWarningEnum = {
    IsActive: 'is_active',
    CurrentTag: 'current_tag'
} as const;

export type PostNamespacesDeleteImagesRequestIgnoreWarningsInnerWarningEnum = typeof PostNamespacesDeleteImagesRequestIgnoreWarningsInnerWarningEnum[keyof typeof PostNamespacesDeleteImagesRequestIgnoreWarningsInnerWarningEnum];

/**
 * 
 * @export
 * @interface PostNamespacesDeleteImagesRequestManifestsInner
 */
export interface PostNamespacesDeleteImagesRequestManifestsInner {
    /**
     * Name of the repository to delete the image from.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesRequestManifestsInner
     */
    'repository': string;
    /**
     * Digest of the image to delete.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesRequestManifestsInner
     */
    'digest': string;
}
/**
 * Deletion not possible.
 * @export
 * @interface PostNamespacesDeleteImagesResponseError
 */
export interface PostNamespacesDeleteImagesResponseError {
    /**
     * Unique ID for this call.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseError
     */
    'txnid'?: string;
    /**
     * The error message.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseError
     */
    'message'?: string;
    /**
     * 
     * @type {PostNamespacesDeleteImagesResponseErrorErrinfo}
     * @memberof PostNamespacesDeleteImagesResponseError
     */
    'errinfo'?: PostNamespacesDeleteImagesResponseErrorErrinfo;
}
/**
 * 
 * @export
 * @interface PostNamespacesDeleteImagesResponseErrorErrinfo
 */
export interface PostNamespacesDeleteImagesResponseErrorErrinfo {
    /**
     * ID of docker user.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfo
     */
    'api_call_docker_id'?: string;
    /**
     * Name of the API operation called.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfo
     */
    'api_call_name'?: string;
    /**
     * Date/time of call start.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfo
     */
    'api_call_start'?: string;
    /**
     * Unique ID for this call.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfo
     */
    'api_call_txnid'?: string;
    /**
     * Type of error.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfo
     */
    'type'?: string;
    /**
     * 
     * @type {PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetails}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfo
     */
    'details'?: PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetails;
}
/**
 * 
 * @export
 * @interface PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetails
 */
export interface PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetails {
    /**
     * Errors from validating delete request. These cannot be ignored.
     * @type {Array<PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInner>}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetails
     */
    'errors'?: Array<PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInner>;
    /**
     * Warnings that can be ignored.  These warnings include:  - is_active: warning when attempting to delete an image that is marked as  active. - current_tag: warning when attempting to delete an image that has one or  more current tags in the repository.  Warnings can be copied from the response to the request. 
     * @type {Array<PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInner>}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetails
     */
    'warnings'?: Array<PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInner>;
}
/**
 * 
 * @export
 * @interface PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInner
 */
export interface PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInner {
    /**
     * Name of the repository of the image that caused the error.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInner
     */
    'repository'?: string;
    /**
     * Digest of the image that caused the error.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInner
     */
    'digest'?: string;
    /**
     * Error type.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInner
     */
    'error'?: PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInnerErrorEnum;
}

export const PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInnerErrorEnum = {
    NotFound: 'not_found',
    Unauthorized: 'unauthorized',
    ChildManifest: 'child_manifest'
} as const;

export type PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInnerErrorEnum = typeof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInnerErrorEnum[keyof typeof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsErrorsInnerErrorEnum];

/**
 * 
 * @export
 * @interface PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInner
 */
export interface PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInner {
    /**
     * Name of the repository of the image that caused the warning.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInner
     */
    'repository'?: string;
    /**
     * Digest of the image that caused the warning.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInner
     */
    'digest'?: string;
    /**
     * Warning type.
     * @type {string}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInner
     */
    'warning'?: PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInnerWarningEnum;
    /**
     * Current tags if warning is `current_tag`.
     * @type {Array<string>}
     * @memberof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInner
     */
    'tags'?: Array<string>;
}

export const PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInnerWarningEnum = {
    IsActive: 'is_active',
    CurrentTag: 'current_tag'
} as const;

export type PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInnerWarningEnum = typeof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInnerWarningEnum[keyof typeof PostNamespacesDeleteImagesResponseErrorErrinfoAllOfDetailsWarningsInnerWarningEnum];

/**
 * Successful delete images response.
 * @export
 * @interface PostNamespacesDeleteImagesResponseSuccess
 */
export interface PostNamespacesDeleteImagesResponseSuccess {
    /**
     * Whether the request was a dry run or not.
     * @type {boolean}
     * @memberof PostNamespacesDeleteImagesResponseSuccess
     */
    'dry_run'?: boolean;
    /**
     * 
     * @type {PostNamespacesDeleteImagesResponseSuccessMetrics}
     * @memberof PostNamespacesDeleteImagesResponseSuccess
     */
    'metrics'?: PostNamespacesDeleteImagesResponseSuccessMetrics;
}
/**
 * 
 * @export
 * @interface PostNamespacesDeleteImagesResponseSuccessMetrics
 */
export interface PostNamespacesDeleteImagesResponseSuccessMetrics {
    /**
     * Number of manifests deleted.
     * @type {number}
     * @memberof PostNamespacesDeleteImagesResponseSuccessMetrics
     */
    'manifest_deletes'?: number;
    /**
     * Number of manifests that failed to delete.
     * @type {number}
     * @memberof PostNamespacesDeleteImagesResponseSuccessMetrics
     */
    'manifest_errors'?: number;
    /**
     * Number of tags deleted.
     * @type {number}
     * @memberof PostNamespacesDeleteImagesResponseSuccessMetrics
     */
    'tag_deletes'?: number;
    /**
     * Number of tags that failed to delete.
     * @type {number}
     * @memberof PostNamespacesDeleteImagesResponseSuccessMetrics
     */
    'tag_errors'?: number;
}
/**
 * failed second factor login response.
 * @export
 * @interface PostUsers2FALoginErrorResponse
 */
export interface PostUsers2FALoginErrorResponse {
    /**
     * Description of the error.
     * @type {string}
     * @memberof PostUsers2FALoginErrorResponse
     */
    'detail'?: string;
}
/**
 * failed user login response or second factor required
 * @export
 * @interface PostUsersLoginErrorResponse
 */
export interface PostUsersLoginErrorResponse {
    /**
     * Description of the error.
     * @type {string}
     * @memberof PostUsersLoginErrorResponse
     */
    'detail': string;
    /**
     * Short time lived token to be used on `/v2/users/2fa-login` to complete the authentication. This field is present only if 2FA is enabled.
     * @type {string}
     * @memberof PostUsersLoginErrorResponse
     */
    'login_2fa_token'?: string | null;
}
/**
 * successful user login response
 * @export
 * @interface PostUsersLoginSuccessResponse
 */
export interface PostUsersLoginSuccessResponse {
    /**
     * Created authentication token.  This token can be used in the HTTP Authorization header as a JWT to authenticate with the Docker Hub APIs. 
     * @type {string}
     * @memberof PostUsersLoginSuccessResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    'type_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface RestrictedImages
 */
export interface RestrictedImages {
    /**
     * Whether or not to restrict image usage for users in the organization.
     * @type {boolean}
     * @memberof RestrictedImages
     */
    'enabled'?: boolean;
    /**
     * Allow usage of official images if \"enabled\" is `true`.
     * @type {boolean}
     * @memberof RestrictedImages
     */
    'allow_official_images'?: boolean;
    /**
     * Allow usage of verified publisher images if \"enabled\" is `true`.
     * @type {boolean}
     * @memberof RestrictedImages
     */
    'allow_verified_publishers'?: boolean;
}
/**
 * 
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
    /**
     * 
     * @type {number}
     * @memberof RpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RpcStatus
     */
    'details'?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface ScimEmail
 */
export interface ScimEmail {
    /**
     * 
     * @type {string}
     * @memberof ScimEmail
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimEmail
     */
    'display'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScimEmail
     */
    'primary'?: boolean;
}
/**
 * 
 * @export
 * @interface ScimError
 */
export interface ScimError {
    /**
     * The status code for the response in string format.
     * @type {string}
     * @memberof ScimError
     */
    'status'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScimError
     */
    'schemas'?: Array<string>;
    /**
     * Details about why the request failed.
     * @type {string}
     * @memberof ScimError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface ScimGroup
 */
export interface ScimGroup {
    /**
     * 
     * @type {string}
     * @memberof ScimGroup
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimGroup
     */
    'display'?: string;
}
/**
 * 
 * @export
 * @interface ScimResourceType
 */
export interface ScimResourceType {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScimResourceType
     */
    'schemas'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ScimResourceType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimResourceType
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimResourceType
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimResourceType
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimResourceType
     */
    'schema'?: string;
}
/**
 * 
 * @export
 * @interface ScimSchema
 */
export interface ScimSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScimSchema
     */
    'schemas'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ScimSchema
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimSchema
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimSchema
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ScimSchemaParentAttribute>}
     * @memberof ScimSchema
     */
    'attributes'?: Array<ScimSchemaParentAttribute>;
}
/**
 * 
 * @export
 * @interface ScimSchemaAttribute
 */
export interface ScimSchemaAttribute {
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaAttribute
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaAttribute
     */
    'type'?: ScimSchemaAttributeTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ScimSchemaAttribute
     */
    'multiValued'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaAttribute
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScimSchemaAttribute
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScimSchemaAttribute
     */
    'caseExact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaAttribute
     */
    'mutability'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaAttribute
     */
    'returned'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaAttribute
     */
    'uniqueness'?: string;
}

export const ScimSchemaAttributeTypeEnum = {
    String: 'string',
    Boolean: 'boolean',
    Complex: 'complex'
} as const;

export type ScimSchemaAttributeTypeEnum = typeof ScimSchemaAttributeTypeEnum[keyof typeof ScimSchemaAttributeTypeEnum];

/**
 * 
 * @export
 * @interface ScimSchemaParentAttribute
 */
export interface ScimSchemaParentAttribute {
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaParentAttribute
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaParentAttribute
     */
    'type'?: ScimSchemaParentAttributeTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ScimSchemaParentAttribute
     */
    'multiValued'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaParentAttribute
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScimSchemaParentAttribute
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScimSchemaParentAttribute
     */
    'caseExact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaParentAttribute
     */
    'mutability'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaParentAttribute
     */
    'returned'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimSchemaParentAttribute
     */
    'uniqueness'?: string;
    /**
     * 
     * @type {Array<ScimSchemaAttribute>}
     * @memberof ScimSchemaParentAttribute
     */
    'subAttributes'?: Array<ScimSchemaAttribute>;
}

export const ScimSchemaParentAttributeTypeEnum = {
    String: 'string',
    Boolean: 'boolean',
    Complex: 'complex'
} as const;

export type ScimSchemaParentAttributeTypeEnum = typeof ScimSchemaParentAttributeTypeEnum[keyof typeof ScimSchemaParentAttributeTypeEnum];

/**
 * 
 * @export
 * @interface ScimServiceProviderConfig
 */
export interface ScimServiceProviderConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScimServiceProviderConfig
     */
    'schemas'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ScimServiceProviderConfig
     */
    'documentationUri'?: string;
    /**
     * 
     * @type {ScimServiceProviderConfigPatch}
     * @memberof ScimServiceProviderConfig
     */
    'patch'?: ScimServiceProviderConfigPatch;
    /**
     * 
     * @type {ScimServiceProviderConfigBulk}
     * @memberof ScimServiceProviderConfig
     */
    'bulk'?: ScimServiceProviderConfigBulk;
    /**
     * 
     * @type {ScimServiceProviderConfigFilter}
     * @memberof ScimServiceProviderConfig
     */
    'filter'?: ScimServiceProviderConfigFilter;
    /**
     * 
     * @type {ScimServiceProviderConfigChangePassword}
     * @memberof ScimServiceProviderConfig
     */
    'changePassword'?: ScimServiceProviderConfigChangePassword;
    /**
     * 
     * @type {ScimServiceProviderConfigSort}
     * @memberof ScimServiceProviderConfig
     */
    'sort'?: ScimServiceProviderConfigSort;
    /**
     * 
     * @type {ScimServiceProviderConfigChangePassword}
     * @memberof ScimServiceProviderConfig
     */
    'etag'?: ScimServiceProviderConfigChangePassword;
    /**
     * 
     * @type {ScimServiceProviderConfigAuthenticationSchemes}
     * @memberof ScimServiceProviderConfig
     */
    'authenticationSchemes'?: ScimServiceProviderConfigAuthenticationSchemes;
}
/**
 * 
 * @export
 * @interface ScimServiceProviderConfigAuthenticationSchemes
 */
export interface ScimServiceProviderConfigAuthenticationSchemes {
    /**
     * 
     * @type {string}
     * @memberof ScimServiceProviderConfigAuthenticationSchemes
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimServiceProviderConfigAuthenticationSchemes
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimServiceProviderConfigAuthenticationSchemes
     */
    'specUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimServiceProviderConfigAuthenticationSchemes
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ScimServiceProviderConfigBulk
 */
export interface ScimServiceProviderConfigBulk {
    /**
     * 
     * @type {boolean}
     * @memberof ScimServiceProviderConfigBulk
     */
    'supported'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ScimServiceProviderConfigBulk
     */
    'maxOperations'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScimServiceProviderConfigBulk
     */
    'maxPayloadSize'?: number;
}
/**
 * 
 * @export
 * @interface ScimServiceProviderConfigChangePassword
 */
export interface ScimServiceProviderConfigChangePassword {
    /**
     * 
     * @type {boolean}
     * @memberof ScimServiceProviderConfigChangePassword
     */
    'supported'?: boolean;
}
/**
 * 
 * @export
 * @interface ScimServiceProviderConfigFilter
 */
export interface ScimServiceProviderConfigFilter {
    /**
     * 
     * @type {boolean}
     * @memberof ScimServiceProviderConfigFilter
     */
    'supported'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ScimServiceProviderConfigFilter
     */
    'maxResults'?: number;
}
/**
 * 
 * @export
 * @interface ScimServiceProviderConfigPatch
 */
export interface ScimServiceProviderConfigPatch {
    /**
     * 
     * @type {boolean}
     * @memberof ScimServiceProviderConfigPatch
     */
    'supported'?: boolean;
}
/**
 * 
 * @export
 * @interface ScimServiceProviderConfigSort
 */
export interface ScimServiceProviderConfigSort {
    /**
     * 
     * @type {boolean}
     * @memberof ScimServiceProviderConfigSort
     */
    'supported'?: boolean;
}
/**
 * 
 * @export
 * @interface ScimUser
 */
export interface ScimUser {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScimUser
     */
    'schemas'?: Array<string>;
    /**
     * The unique identifier for the user. A v4 UUID.
     * @type {string}
     * @memberof ScimUser
     */
    'id'?: string;
    /**
     * The user\'s email address. This must be reachable via email.
     * @type {string}
     * @memberof ScimUser
     */
    'userName'?: string;
    /**
     * 
     * @type {ScimUserName}
     * @memberof ScimUser
     */
    'name'?: ScimUserName;
    /**
     * The username in Docker. Also known as the \"Docker ID\".
     * @type {string}
     * @memberof ScimUser
     */
    'displayName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScimUser
     */
    'active'?: boolean;
    /**
     * 
     * @type {Array<ScimEmail>}
     * @memberof ScimUser
     */
    'emails'?: Array<ScimEmail>;
    /**
     * 
     * @type {Array<ScimGroup>}
     * @memberof ScimUser
     */
    'groups'?: Array<ScimGroup>;
    /**
     * 
     * @type {ScimUserMeta}
     * @memberof ScimUser
     */
    'meta'?: ScimUserMeta;
}
/**
 * 
 * @export
 * @interface ScimUserMeta
 */
export interface ScimUserMeta {
    /**
     * 
     * @type {string}
     * @memberof ScimUserMeta
     */
    'resourceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimUserMeta
     */
    'location'?: string;
    /**
     * The creation date for the user as a RFC3339 formatted string.
     * @type {string}
     * @memberof ScimUserMeta
     */
    'created'?: string;
    /**
     * The date the user was last modified as a RFC3339 formatted string.
     * @type {string}
     * @memberof ScimUserMeta
     */
    'lastModified'?: string;
}
/**
 * 
 * @export
 * @interface ScimUserName
 */
export interface ScimUserName {
    /**
     * 
     * @type {string}
     * @memberof ScimUserName
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScimUserName
     */
    'familyName'?: string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * tag ID
     * @type {number}
     * @memberof Tag
     */
    'id'?: number;
    /**
     * 
     * @type {Image}
     * @memberof Tag
     */
    'images'?: Image;
    /**
     * ID of the user that pushed the tag
     * @type {number}
     * @memberof Tag
     */
    'creator'?: number;
    /**
     * datetime of last update
     * @type {string}
     * @memberof Tag
     */
    'last_updated'?: string | null;
    /**
     * ID of the last user that updated the tag
     * @type {number}
     * @memberof Tag
     */
    'last_updater'?: number;
    /**
     * Hub username of the user that updated the tag
     * @type {string}
     * @memberof Tag
     */
    'last_updater_username'?: string;
    /**
     * name of the tag
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
    /**
     * repository ID
     * @type {number}
     * @memberof Tag
     */
    'repository'?: number;
    /**
     * compressed size (sum of all layers) of the tagged image
     * @type {number}
     * @memberof Tag
     */
    'full_size'?: number;
    /**
     * repository API version
     * @type {string}
     * @memberof Tag
     */
    'v2'?: string;
    /**
     * whether a tag has been pushed to or pulled in the past month
     * @type {string}
     * @memberof Tag
     */
    'status'?: TagStatusEnum;
    /**
     * datetime of last pull
     * @type {string}
     * @memberof Tag
     */
    'tag_last_pulled'?: string | null;
    /**
     * datetime of last push
     * @type {string}
     * @memberof Tag
     */
    'tag_last_pushed'?: string | null;
}

export const TagStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type TagStatusEnum = typeof TagStatusEnum[keyof typeof TagStatusEnum];

/**
 * Second factor user login details
 * @export
 * @interface Users2FALoginRequest
 */
export interface Users2FALoginRequest {
    /**
     * The intermediate 2FA token returned from `/v2/users/login` API.
     * @type {string}
     * @memberof Users2FALoginRequest
     */
    'login_2fa_token': string;
    /**
     * The Time-based One-Time Password of the Docker Hub account to authenticate with.
     * @type {string}
     * @memberof Users2FALoginRequest
     */
    'code': string;
}
/**
 * User login details
 * @export
 * @interface UsersLoginRequest
 */
export interface UsersLoginRequest {
    /**
     * The username of the Docker Hub account to authenticate with.
     * @type {string}
     * @memberof UsersLoginRequest
     */
    'username': string;
    /**
     * The password or personal access token (PAT) of the Docker Hub account to authenticate with.
     * @type {string}
     * @memberof UsersLoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface V2AccessTokensUuidGet200Response
 */
export interface V2AccessTokensUuidGet200Response {
    /**
     * 
     * @type {string}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'creator_ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'creator_ua'?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'last_used'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'generated_by'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'token_label'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V2AccessTokensUuidGet200Response
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V2OrgsNameSettingsPutRequest
 */
export interface V2OrgsNameSettingsPutRequest {
    /**
     * 
     * @type {V2OrgsNameSettingsPutRequestRestrictedImages}
     * @memberof V2OrgsNameSettingsPutRequest
     */
    'restricted_images': V2OrgsNameSettingsPutRequestRestrictedImages;
}
/**
 * 
 * @export
 * @interface V2OrgsNameSettingsPutRequestRestrictedImages
 */
export interface V2OrgsNameSettingsPutRequestRestrictedImages {
    /**
     * Whether or not to restrict image usage for users in the organization.
     * @type {boolean}
     * @memberof V2OrgsNameSettingsPutRequestRestrictedImages
     */
    'enabled': boolean;
    /**
     * Allow usage of official images if \"enabled\" is `true`.
     * @type {boolean}
     * @memberof V2OrgsNameSettingsPutRequestRestrictedImages
     */
    'allow_official_images': boolean;
    /**
     * Allow usage of verified publisher images if \"enabled\" is `true`.
     * @type {boolean}
     * @memberof V2OrgsNameSettingsPutRequestRestrictedImages
     */
    'allow_verified_publishers': boolean;
}
/**
 * 
 * @export
 * @interface V2Scim20ResourceTypesGet200Response
 */
export interface V2Scim20ResourceTypesGet200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20ResourceTypesGet200Response
     */
    'schemas'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof V2Scim20ResourceTypesGet200Response
     */
    'totalResults'?: number;
    /**
     * 
     * @type {Array<ScimResourceType>}
     * @memberof V2Scim20ResourceTypesGet200Response
     */
    'resources'?: Array<ScimResourceType>;
}
/**
 * 
 * @export
 * @interface V2Scim20ResourceTypesNameGet404Response
 */
export interface V2Scim20ResourceTypesNameGet404Response {
    /**
     * 
     * @type {any}
     * @memberof V2Scim20ResourceTypesNameGet404Response
     */
    'status'?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20ResourceTypesNameGet404Response
     */
    'schemas'?: Array<string>;
    /**
     * Details about why the request failed.
     * @type {string}
     * @memberof V2Scim20ResourceTypesNameGet404Response
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface V2Scim20SchemasGet200Response
 */
export interface V2Scim20SchemasGet200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20SchemasGet200Response
     */
    'schemas'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof V2Scim20SchemasGet200Response
     */
    'totalResults'?: number;
    /**
     * 
     * @type {Array<ScimSchema>}
     * @memberof V2Scim20SchemasGet200Response
     */
    'resources'?: Array<ScimSchema>;
}
/**
 * 
 * @export
 * @interface V2Scim20ServiceProviderConfigGet401Response
 */
export interface V2Scim20ServiceProviderConfigGet401Response {
    /**
     * 
     * @type {any}
     * @memberof V2Scim20ServiceProviderConfigGet401Response
     */
    'status'?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20ServiceProviderConfigGet401Response
     */
    'schemas'?: Array<string>;
    /**
     * Details about why the request failed.
     * @type {string}
     * @memberof V2Scim20ServiceProviderConfigGet401Response
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface V2Scim20ServiceProviderConfigGet500Response
 */
export interface V2Scim20ServiceProviderConfigGet500Response {
    /**
     * 
     * @type {any}
     * @memberof V2Scim20ServiceProviderConfigGet500Response
     */
    'status'?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20ServiceProviderConfigGet500Response
     */
    'schemas'?: Array<string>;
    /**
     * Details about why the request failed.
     * @type {string}
     * @memberof V2Scim20ServiceProviderConfigGet500Response
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface V2Scim20UsersGet200Response
 */
export interface V2Scim20UsersGet200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20UsersGet200Response
     */
    'schemas'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof V2Scim20UsersGet200Response
     */
    'totalResults'?: number;
    /**
     * 
     * @type {number}
     * @memberof V2Scim20UsersGet200Response
     */
    'startIndex'?: number;
    /**
     * 
     * @type {number}
     * @memberof V2Scim20UsersGet200Response
     */
    'itemsPerPage'?: number;
    /**
     * 
     * @type {Array<ScimUser>}
     * @memberof V2Scim20UsersGet200Response
     */
    'resources'?: Array<ScimUser>;
}
/**
 * 
 * @export
 * @interface V2Scim20UsersGet400Response
 */
export interface V2Scim20UsersGet400Response {
    /**
     * 
     * @type {any}
     * @memberof V2Scim20UsersGet400Response
     */
    'status'?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20UsersGet400Response
     */
    'schemas'?: Array<string>;
    /**
     * Details about why the request failed.
     * @type {string}
     * @memberof V2Scim20UsersGet400Response
     */
    'detail'?: string;
    /**
     * Some types of errors will return this per the specification.
     * @type {string}
     * @memberof V2Scim20UsersGet400Response
     */
    'scimType'?: string;
}
/**
 * 
 * @export
 * @interface V2Scim20UsersGet403Response
 */
export interface V2Scim20UsersGet403Response {
    /**
     * 
     * @type {any}
     * @memberof V2Scim20UsersGet403Response
     */
    'status'?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20UsersGet403Response
     */
    'schemas'?: Array<string>;
    /**
     * Details about why the request failed.
     * @type {string}
     * @memberof V2Scim20UsersGet403Response
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface V2Scim20UsersIdPutRequest
 */
export interface V2Scim20UsersIdPutRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20UsersIdPutRequest
     */
    'schemas': Array<string>;
    /**
     * 
     * @type {V2Scim20UsersIdPutRequestName}
     * @memberof V2Scim20UsersIdPutRequest
     */
    'name'?: V2Scim20UsersIdPutRequestName;
    /**
     * If this is omitted from the request, it will default to false resulting in a deactivated user.
     * @type {boolean}
     * @memberof V2Scim20UsersIdPutRequest
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface V2Scim20UsersIdPutRequestName
 */
export interface V2Scim20UsersIdPutRequestName {
    /**
     * 
     * @type {string}
     * @memberof V2Scim20UsersIdPutRequestName
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Scim20UsersIdPutRequestName
     */
    'familyName'?: string;
}
/**
 * 
 * @export
 * @interface V2Scim20UsersPost409Response
 */
export interface V2Scim20UsersPost409Response {
    /**
     * 
     * @type {any}
     * @memberof V2Scim20UsersPost409Response
     */
    'status'?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20UsersPost409Response
     */
    'schemas'?: Array<string>;
    /**
     * Details about why the request failed.
     * @type {string}
     * @memberof V2Scim20UsersPost409Response
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface V2Scim20UsersPostRequest
 */
export interface V2Scim20UsersPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof V2Scim20UsersPostRequest
     */
    'schemas': Array<string>;
    /**
     * The user\'s email address. This must be reachable via email.
     * @type {string}
     * @memberof V2Scim20UsersPostRequest
     */
    'userName': string;
    /**
     * 
     * @type {ScimUserName}
     * @memberof V2Scim20UsersPostRequest
     */
    'name'?: ScimUserName;
}
/**
 * Used to error if input validation fails.
 * @export
 * @interface ValueError
 */
export interface ValueError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValueError
     */
    'fields'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValueError
     */
    'text'?: string;
}

/**
 * AccessTokensApi - axios parameter creator
 * @export
 */
export const AccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of personal access tokens.
         * @summary Get a list of personal access tokens
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensGet: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and returns a personal access token.
         * @summary Create a personal access token
         * @param {CreateAccessTokenRequest} createAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensPost: async (createAccessTokenRequest: CreateAccessTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccessTokenRequest' is not null or undefined
            assertParamExists('v2AccessTokensPost', 'createAccessTokenRequest', createAccessTokenRequest)
            const localVarPath = `/v2/access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a personal access token permanently. This cannot be undone. 
         * @summary Delete a personal access token
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensUuidDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('v2AccessTokensUuidDelete', 'uuid', uuid)
            const localVarPath = `/v2/access-tokens/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a personal access token by UUID.
         * @summary Get a personal access token
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensUuidGet: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('v2AccessTokensUuidGet', 'uuid', uuid)
            const localVarPath = `/v2/access-tokens/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a personal access token partially. You can either update the token\'s label or enable/disable it. 
         * @summary Update a personal access token
         * @param {string} uuid 
         * @param {PatchAccessTokenRequest} patchAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensUuidPatch: async (uuid: string, patchAccessTokenRequest: PatchAccessTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('v2AccessTokensUuidPatch', 'uuid', uuid)
            // verify required parameter 'patchAccessTokenRequest' is not null or undefined
            assertParamExists('v2AccessTokensUuidPatch', 'patchAccessTokenRequest', patchAccessTokenRequest)
            const localVarPath = `/v2/access-tokens/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessTokensApi - functional programming interface
 * @export
 */
export const AccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a paginated list of personal access tokens.
         * @summary Get a list of personal access tokens
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccessTokensGet(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccessTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccessTokensGet(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessTokensApi.v2AccessTokensGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates and returns a personal access token.
         * @summary Create a personal access token
         * @param {CreateAccessTokenRequest} createAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccessTokensPost(createAccessTokenRequest: CreateAccessTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccessTokensPost(createAccessTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessTokensApi.v2AccessTokensPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a personal access token permanently. This cannot be undone. 
         * @summary Delete a personal access token
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccessTokensUuidDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccessTokensUuidDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessTokensApi.v2AccessTokensUuidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a personal access token by UUID.
         * @summary Get a personal access token
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccessTokensUuidGet(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AccessTokensUuidGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccessTokensUuidGet(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessTokensApi.v2AccessTokensUuidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a personal access token partially. You can either update the token\'s label or enable/disable it. 
         * @summary Update a personal access token
         * @param {string} uuid 
         * @param {PatchAccessTokenRequest} patchAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AccessTokensUuidPatch(uuid: string, patchAccessTokenRequest: PatchAccessTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AccessTokensUuidPatch(uuid, patchAccessTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessTokensApi.v2AccessTokensUuidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessTokensApi - factory interface
 * @export
 */
export const AccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessTokensApiFp(configuration)
    return {
        /**
         * Returns a paginated list of personal access tokens.
         * @summary Get a list of personal access tokens
         * @param {AccessTokensApiV2AccessTokensGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensGet(requestParameters: AccessTokensApiV2AccessTokensGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetAccessTokensResponse> {
            return localVarFp.v2AccessTokensGet(requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and returns a personal access token.
         * @summary Create a personal access token
         * @param {AccessTokensApiV2AccessTokensPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensPost(requestParameters: AccessTokensApiV2AccessTokensPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessToken> {
            return localVarFp.v2AccessTokensPost(requestParameters.createAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a personal access token permanently. This cannot be undone. 
         * @summary Delete a personal access token
         * @param {AccessTokensApiV2AccessTokensUuidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensUuidDelete(requestParameters: AccessTokensApiV2AccessTokensUuidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v2AccessTokensUuidDelete(requestParameters.uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a personal access token by UUID.
         * @summary Get a personal access token
         * @param {AccessTokensApiV2AccessTokensUuidGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensUuidGet(requestParameters: AccessTokensApiV2AccessTokensUuidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2AccessTokensUuidGet200Response> {
            return localVarFp.v2AccessTokensUuidGet(requestParameters.uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a personal access token partially. You can either update the token\'s label or enable/disable it. 
         * @summary Update a personal access token
         * @param {AccessTokensApiV2AccessTokensUuidPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AccessTokensUuidPatch(requestParameters: AccessTokensApiV2AccessTokensUuidPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessToken> {
            return localVarFp.v2AccessTokensUuidPatch(requestParameters.uuid, requestParameters.patchAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for v2AccessTokensGet operation in AccessTokensApi.
 * @export
 * @interface AccessTokensApiV2AccessTokensGetRequest
 */
export interface AccessTokensApiV2AccessTokensGetRequest {
    /**
     * 
     * @type {number}
     * @memberof AccessTokensApiV2AccessTokensGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof AccessTokensApiV2AccessTokensGet
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v2AccessTokensPost operation in AccessTokensApi.
 * @export
 * @interface AccessTokensApiV2AccessTokensPostRequest
 */
export interface AccessTokensApiV2AccessTokensPostRequest {
    /**
     * 
     * @type {CreateAccessTokenRequest}
     * @memberof AccessTokensApiV2AccessTokensPost
     */
    readonly createAccessTokenRequest: CreateAccessTokenRequest
}

/**
 * Request parameters for v2AccessTokensUuidDelete operation in AccessTokensApi.
 * @export
 * @interface AccessTokensApiV2AccessTokensUuidDeleteRequest
 */
export interface AccessTokensApiV2AccessTokensUuidDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof AccessTokensApiV2AccessTokensUuidDelete
     */
    readonly uuid: string
}

/**
 * Request parameters for v2AccessTokensUuidGet operation in AccessTokensApi.
 * @export
 * @interface AccessTokensApiV2AccessTokensUuidGetRequest
 */
export interface AccessTokensApiV2AccessTokensUuidGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AccessTokensApiV2AccessTokensUuidGet
     */
    readonly uuid: string
}

/**
 * Request parameters for v2AccessTokensUuidPatch operation in AccessTokensApi.
 * @export
 * @interface AccessTokensApiV2AccessTokensUuidPatchRequest
 */
export interface AccessTokensApiV2AccessTokensUuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AccessTokensApiV2AccessTokensUuidPatch
     */
    readonly uuid: string

    /**
     * 
     * @type {PatchAccessTokenRequest}
     * @memberof AccessTokensApiV2AccessTokensUuidPatch
     */
    readonly patchAccessTokenRequest: PatchAccessTokenRequest
}

/**
 * AccessTokensApi - object-oriented interface
 * @export
 * @class AccessTokensApi
 * @extends {BaseAPI}
 */
export class AccessTokensApi extends BaseAPI {
    /**
     * Returns a paginated list of personal access tokens.
     * @summary Get a list of personal access tokens
     * @param {AccessTokensApiV2AccessTokensGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public v2AccessTokensGet(requestParameters: AccessTokensApiV2AccessTokensGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).v2AccessTokensGet(requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and returns a personal access token.
     * @summary Create a personal access token
     * @param {AccessTokensApiV2AccessTokensPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public v2AccessTokensPost(requestParameters: AccessTokensApiV2AccessTokensPostRequest, options?: RawAxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).v2AccessTokensPost(requestParameters.createAccessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a personal access token permanently. This cannot be undone. 
     * @summary Delete a personal access token
     * @param {AccessTokensApiV2AccessTokensUuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public v2AccessTokensUuidDelete(requestParameters: AccessTokensApiV2AccessTokensUuidDeleteRequest, options?: RawAxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).v2AccessTokensUuidDelete(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a personal access token by UUID.
     * @summary Get a personal access token
     * @param {AccessTokensApiV2AccessTokensUuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public v2AccessTokensUuidGet(requestParameters: AccessTokensApiV2AccessTokensUuidGetRequest, options?: RawAxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).v2AccessTokensUuidGet(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a personal access token partially. You can either update the token\'s label or enable/disable it. 
     * @summary Update a personal access token
     * @param {AccessTokensApiV2AccessTokensUuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public v2AccessTokensUuidPatch(requestParameters: AccessTokensApiV2AccessTokensUuidPatchRequest, options?: RawAxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).v2AccessTokensUuidPatch(requestParameters.uuid, requestParameters.patchAccessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuditLogsApi - axios parameter creator
 * @export
 */
export const AuditLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get audit log actions for a namespace to be used as a filter for querying audit events.
         * @summary Returns list of audit log actions
         * @param {string} account Namespace to query audit log actions for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogsGetAuditActions: async (account: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('auditLogsGetAuditActions', 'account', account)
            const localVarPath = `/v2/auditlogs/{account}/actions`
                .replace(`{${"account"}}`, encodeURIComponent(String(account)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get audit log events for a given namespace.
         * @summary Returns list of audit log events
         * @param {string} account Namespace to query audit logs for.
         * @param {string} [action] action name one of [\&quot;repo.tag.push\&quot;, ...]. Optional parameter to filter specific audit log actions.
         * @param {string} [name] name. Optional parameter to filter audit log events to a specific name. For repository events, this is the name of the repository. For organization events, this is the name of the organization. For team member events, this is the username of the team member.
         * @param {string} [actor] actor name. Optional parameter to filter audit log events to the specific user who triggered the event.
         * @param {string} [from] Start of the time window you wish to query audit events for.
         * @param {string} [to] End of the time window you wish to query audit events for.
         * @param {number} [page] page - specify page number. Page number to get.
         * @param {number} [pageSize] page_size - specify page size. Number of events to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogsGetAuditLogs: async (account: string, action?: string, name?: string, actor?: string, from?: string, to?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('auditLogsGetAuditLogs', 'account', account)
            const localVarPath = `/v2/auditlogs/{account}`
                .replace(`{${"account"}}`, encodeURIComponent(String(account)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (actor !== undefined) {
                localVarQueryParameter['actor'] = actor;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogsApi - functional programming interface
 * @export
 */
export const AuditLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get audit log actions for a namespace to be used as a filter for querying audit events.
         * @summary Returns list of audit log actions
         * @param {string} account Namespace to query audit log actions for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auditLogsGetAuditActions(account: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuditActionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auditLogsGetAuditActions(account, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditLogsApi.auditLogsGetAuditActions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get audit log events for a given namespace.
         * @summary Returns list of audit log events
         * @param {string} account Namespace to query audit logs for.
         * @param {string} [action] action name one of [\&quot;repo.tag.push\&quot;, ...]. Optional parameter to filter specific audit log actions.
         * @param {string} [name] name. Optional parameter to filter audit log events to a specific name. For repository events, this is the name of the repository. For organization events, this is the name of the organization. For team member events, this is the username of the team member.
         * @param {string} [actor] actor name. Optional parameter to filter audit log events to the specific user who triggered the event.
         * @param {string} [from] Start of the time window you wish to query audit events for.
         * @param {string} [to] End of the time window you wish to query audit events for.
         * @param {number} [page] page - specify page number. Page number to get.
         * @param {number} [pageSize] page_size - specify page size. Number of events to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auditLogsGetAuditLogs(account: string, action?: string, name?: string, actor?: string, from?: string, to?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuditLogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auditLogsGetAuditLogs(account, action, name, actor, from, to, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditLogsApi.auditLogsGetAuditLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuditLogsApi - factory interface
 * @export
 */
export const AuditLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditLogsApiFp(configuration)
    return {
        /**
         * Get audit log actions for a namespace to be used as a filter for querying audit events.
         * @summary Returns list of audit log actions
         * @param {AuditLogsApiAuditLogsGetAuditActionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogsGetAuditActions(requestParameters: AuditLogsApiAuditLogsGetAuditActionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetAuditActionsResponse> {
            return localVarFp.auditLogsGetAuditActions(requestParameters.account, options).then((request) => request(axios, basePath));
        },
        /**
         * Get audit log events for a given namespace.
         * @summary Returns list of audit log events
         * @param {AuditLogsApiAuditLogsGetAuditLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogsGetAuditLogs(requestParameters: AuditLogsApiAuditLogsGetAuditLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetAuditLogsResponse> {
            return localVarFp.auditLogsGetAuditLogs(requestParameters.account, requestParameters.action, requestParameters.name, requestParameters.actor, requestParameters.from, requestParameters.to, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for auditLogsGetAuditActions operation in AuditLogsApi.
 * @export
 * @interface AuditLogsApiAuditLogsGetAuditActionsRequest
 */
export interface AuditLogsApiAuditLogsGetAuditActionsRequest {
    /**
     * Namespace to query audit log actions for.
     * @type {string}
     * @memberof AuditLogsApiAuditLogsGetAuditActions
     */
    readonly account: string
}

/**
 * Request parameters for auditLogsGetAuditLogs operation in AuditLogsApi.
 * @export
 * @interface AuditLogsApiAuditLogsGetAuditLogsRequest
 */
export interface AuditLogsApiAuditLogsGetAuditLogsRequest {
    /**
     * Namespace to query audit logs for.
     * @type {string}
     * @memberof AuditLogsApiAuditLogsGetAuditLogs
     */
    readonly account: string

    /**
     * action name one of [\&quot;repo.tag.push\&quot;, ...]. Optional parameter to filter specific audit log actions.
     * @type {string}
     * @memberof AuditLogsApiAuditLogsGetAuditLogs
     */
    readonly action?: string

    /**
     * name. Optional parameter to filter audit log events to a specific name. For repository events, this is the name of the repository. For organization events, this is the name of the organization. For team member events, this is the username of the team member.
     * @type {string}
     * @memberof AuditLogsApiAuditLogsGetAuditLogs
     */
    readonly name?: string

    /**
     * actor name. Optional parameter to filter audit log events to the specific user who triggered the event.
     * @type {string}
     * @memberof AuditLogsApiAuditLogsGetAuditLogs
     */
    readonly actor?: string

    /**
     * Start of the time window you wish to query audit events for.
     * @type {string}
     * @memberof AuditLogsApiAuditLogsGetAuditLogs
     */
    readonly from?: string

    /**
     * End of the time window you wish to query audit events for.
     * @type {string}
     * @memberof AuditLogsApiAuditLogsGetAuditLogs
     */
    readonly to?: string

    /**
     * page - specify page number. Page number to get.
     * @type {number}
     * @memberof AuditLogsApiAuditLogsGetAuditLogs
     */
    readonly page?: number

    /**
     * page_size - specify page size. Number of events to return per page.
     * @type {number}
     * @memberof AuditLogsApiAuditLogsGetAuditLogs
     */
    readonly pageSize?: number
}

/**
 * AuditLogsApi - object-oriented interface
 * @export
 * @class AuditLogsApi
 * @extends {BaseAPI}
 */
export class AuditLogsApi extends BaseAPI {
    /**
     * Get audit log actions for a namespace to be used as a filter for querying audit events.
     * @summary Returns list of audit log actions
     * @param {AuditLogsApiAuditLogsGetAuditActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogsApi
     */
    public auditLogsGetAuditActions(requestParameters: AuditLogsApiAuditLogsGetAuditActionsRequest, options?: RawAxiosRequestConfig) {
        return AuditLogsApiFp(this.configuration).auditLogsGetAuditActions(requestParameters.account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get audit log events for a given namespace.
     * @summary Returns list of audit log events
     * @param {AuditLogsApiAuditLogsGetAuditLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogsApi
     */
    public auditLogsGetAuditLogs(requestParameters: AuditLogsApiAuditLogsGetAuditLogsRequest, options?: RawAxiosRequestConfig) {
        return AuditLogsApiFp(this.configuration).auditLogsGetAuditLogs(requestParameters.account, requestParameters.action, requestParameters.name, requestParameters.actor, requestParameters.from, requestParameters.to, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * When a user has two-factor authentication (2FA) enabled, this is the second call to perform after `/v2/users/login` call.  Creates and returns a bearer token in JWT format that you can use to authenticate with Docker Hub APIs.  The returned token is used in the HTTP Authorization header like `Authorization: Bearer {TOKEN}`.  Most Docker Hub APIs require this token either to consume or to get detailed information. For example, to list images in a private repository. 
         * @summary Second factor authentication
         * @param {Users2FALoginRequest} users2FALoginRequest Login details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers2FALogin: async (users2FALoginRequest: Users2FALoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'users2FALoginRequest' is not null or undefined
            assertParamExists('postUsers2FALogin', 'users2FALoginRequest', users2FALoginRequest)
            const localVarPath = `/v2/users/2fa-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(users2FALoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and returns a bearer token in JWT format that you can use to authenticate with Docker Hub APIs.  The returned token is used in the HTTP Authorization header like `Authorization: Bearer {TOKEN}`.  Most Docker Hub APIs require this token either to consume or to get detailed information. For example, to list  images in a private repository.  _**As of Monday, September 16, 2024, this route requires a PAT instead of a password if your organization has  SSO enforced.**_ 
         * @summary Create an authentication token
         * @param {UsersLoginRequest} usersLoginRequest Login details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersLogin: async (usersLoginRequest: UsersLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersLoginRequest' is not null or undefined
            assertParamExists('postUsersLogin', 'usersLoginRequest', usersLoginRequest)
            const localVarPath = `/v2/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * When a user has two-factor authentication (2FA) enabled, this is the second call to perform after `/v2/users/login` call.  Creates and returns a bearer token in JWT format that you can use to authenticate with Docker Hub APIs.  The returned token is used in the HTTP Authorization header like `Authorization: Bearer {TOKEN}`.  Most Docker Hub APIs require this token either to consume or to get detailed information. For example, to list images in a private repository. 
         * @summary Second factor authentication
         * @param {Users2FALoginRequest} users2FALoginRequest Login details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsers2FALogin(users2FALoginRequest: Users2FALoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostUsersLoginSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsers2FALogin(users2FALoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.postUsers2FALogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates and returns a bearer token in JWT format that you can use to authenticate with Docker Hub APIs.  The returned token is used in the HTTP Authorization header like `Authorization: Bearer {TOKEN}`.  Most Docker Hub APIs require this token either to consume or to get detailed information. For example, to list  images in a private repository.  _**As of Monday, September 16, 2024, this route requires a PAT instead of a password if your organization has  SSO enforced.**_ 
         * @summary Create an authentication token
         * @param {UsersLoginRequest} usersLoginRequest Login details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersLogin(usersLoginRequest: UsersLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostUsersLoginSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersLogin(usersLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.postUsersLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * When a user has two-factor authentication (2FA) enabled, this is the second call to perform after `/v2/users/login` call.  Creates and returns a bearer token in JWT format that you can use to authenticate with Docker Hub APIs.  The returned token is used in the HTTP Authorization header like `Authorization: Bearer {TOKEN}`.  Most Docker Hub APIs require this token either to consume or to get detailed information. For example, to list images in a private repository. 
         * @summary Second factor authentication
         * @param {AuthenticationApiPostUsers2FALoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers2FALogin(requestParameters: AuthenticationApiPostUsers2FALoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostUsersLoginSuccessResponse> {
            return localVarFp.postUsers2FALogin(requestParameters.users2FALoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and returns a bearer token in JWT format that you can use to authenticate with Docker Hub APIs.  The returned token is used in the HTTP Authorization header like `Authorization: Bearer {TOKEN}`.  Most Docker Hub APIs require this token either to consume or to get detailed information. For example, to list  images in a private repository.  _**As of Monday, September 16, 2024, this route requires a PAT instead of a password if your organization has  SSO enforced.**_ 
         * @summary Create an authentication token
         * @param {AuthenticationApiPostUsersLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersLogin(requestParameters: AuthenticationApiPostUsersLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostUsersLoginSuccessResponse> {
            return localVarFp.postUsersLogin(requestParameters.usersLoginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for postUsers2FALogin operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiPostUsers2FALoginRequest
 */
export interface AuthenticationApiPostUsers2FALoginRequest {
    /**
     * Login details.
     * @type {Users2FALoginRequest}
     * @memberof AuthenticationApiPostUsers2FALogin
     */
    readonly users2FALoginRequest: Users2FALoginRequest
}

/**
 * Request parameters for postUsersLogin operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiPostUsersLoginRequest
 */
export interface AuthenticationApiPostUsersLoginRequest {
    /**
     * Login details.
     * @type {UsersLoginRequest}
     * @memberof AuthenticationApiPostUsersLogin
     */
    readonly usersLoginRequest: UsersLoginRequest
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * When a user has two-factor authentication (2FA) enabled, this is the second call to perform after `/v2/users/login` call.  Creates and returns a bearer token in JWT format that you can use to authenticate with Docker Hub APIs.  The returned token is used in the HTTP Authorization header like `Authorization: Bearer {TOKEN}`.  Most Docker Hub APIs require this token either to consume or to get detailed information. For example, to list images in a private repository. 
     * @summary Second factor authentication
     * @param {AuthenticationApiPostUsers2FALoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public postUsers2FALogin(requestParameters: AuthenticationApiPostUsers2FALoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).postUsers2FALogin(requestParameters.users2FALoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and returns a bearer token in JWT format that you can use to authenticate with Docker Hub APIs.  The returned token is used in the HTTP Authorization header like `Authorization: Bearer {TOKEN}`.  Most Docker Hub APIs require this token either to consume or to get detailed information. For example, to list  images in a private repository.  _**As of Monday, September 16, 2024, this route requires a PAT instead of a password if your organization has  SSO enforced.**_ 
     * @summary Create an authentication token
     * @param {AuthenticationApiPostUsersLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public postUsersLogin(requestParameters: AuthenticationApiPostUsersLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).postUsersLogin(requestParameters.usersLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrgSettingsApi - axios parameter creator
 * @export
 */
export const OrgSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns organization settings by name. 
         * @summary Get organization settings
         * @param {string} name Name of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrgsNameSettingsGet: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('v2OrgsNameSettingsGet', 'name', name)
            const localVarPath = `/v2/orgs/{name}/settings`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an organization\'s settings. Some settings are only used when the organization is on a business plan.  ***Only users with administrative privileges for the organization (owner role) can modify these settings.***  The following settings are only used on a business plan: - `restricted_images` 
         * @summary Update organization settings
         * @param {string} name Name of the organization.
         * @param {V2OrgsNameSettingsPutRequest} v2OrgsNameSettingsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrgsNameSettingsPut: async (name: string, v2OrgsNameSettingsPutRequest: V2OrgsNameSettingsPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('v2OrgsNameSettingsPut', 'name', name)
            // verify required parameter 'v2OrgsNameSettingsPutRequest' is not null or undefined
            assertParamExists('v2OrgsNameSettingsPut', 'v2OrgsNameSettingsPutRequest', v2OrgsNameSettingsPutRequest)
            const localVarPath = `/v2/orgs/{name}/settings`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2OrgsNameSettingsPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgSettingsApi - functional programming interface
 * @export
 */
export const OrgSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns organization settings by name. 
         * @summary Get organization settings
         * @param {string} name Name of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2OrgsNameSettingsGet(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2OrgsNameSettingsGet(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgSettingsApi.v2OrgsNameSettingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an organization\'s settings. Some settings are only used when the organization is on a business plan.  ***Only users with administrative privileges for the organization (owner role) can modify these settings.***  The following settings are only used on a business plan: - `restricted_images` 
         * @summary Update organization settings
         * @param {string} name Name of the organization.
         * @param {V2OrgsNameSettingsPutRequest} v2OrgsNameSettingsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2OrgsNameSettingsPut(name: string, v2OrgsNameSettingsPutRequest: V2OrgsNameSettingsPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2OrgsNameSettingsPut(name, v2OrgsNameSettingsPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgSettingsApi.v2OrgsNameSettingsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrgSettingsApi - factory interface
 * @export
 */
export const OrgSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgSettingsApiFp(configuration)
    return {
        /**
         * Returns organization settings by name. 
         * @summary Get organization settings
         * @param {OrgSettingsApiV2OrgsNameSettingsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrgsNameSettingsGet(requestParameters: OrgSettingsApiV2OrgsNameSettingsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrgSettings> {
            return localVarFp.v2OrgsNameSettingsGet(requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an organization\'s settings. Some settings are only used when the organization is on a business plan.  ***Only users with administrative privileges for the organization (owner role) can modify these settings.***  The following settings are only used on a business plan: - `restricted_images` 
         * @summary Update organization settings
         * @param {OrgSettingsApiV2OrgsNameSettingsPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrgsNameSettingsPut(requestParameters: OrgSettingsApiV2OrgsNameSettingsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrgSettings> {
            return localVarFp.v2OrgsNameSettingsPut(requestParameters.name, requestParameters.v2OrgsNameSettingsPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for v2OrgsNameSettingsGet operation in OrgSettingsApi.
 * @export
 * @interface OrgSettingsApiV2OrgsNameSettingsGetRequest
 */
export interface OrgSettingsApiV2OrgsNameSettingsGetRequest {
    /**
     * Name of the organization.
     * @type {string}
     * @memberof OrgSettingsApiV2OrgsNameSettingsGet
     */
    readonly name: string
}

/**
 * Request parameters for v2OrgsNameSettingsPut operation in OrgSettingsApi.
 * @export
 * @interface OrgSettingsApiV2OrgsNameSettingsPutRequest
 */
export interface OrgSettingsApiV2OrgsNameSettingsPutRequest {
    /**
     * Name of the organization.
     * @type {string}
     * @memberof OrgSettingsApiV2OrgsNameSettingsPut
     */
    readonly name: string

    /**
     * 
     * @type {V2OrgsNameSettingsPutRequest}
     * @memberof OrgSettingsApiV2OrgsNameSettingsPut
     */
    readonly v2OrgsNameSettingsPutRequest: V2OrgsNameSettingsPutRequest
}

/**
 * OrgSettingsApi - object-oriented interface
 * @export
 * @class OrgSettingsApi
 * @extends {BaseAPI}
 */
export class OrgSettingsApi extends BaseAPI {
    /**
     * Returns organization settings by name. 
     * @summary Get organization settings
     * @param {OrgSettingsApiV2OrgsNameSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgSettingsApi
     */
    public v2OrgsNameSettingsGet(requestParameters: OrgSettingsApiV2OrgsNameSettingsGetRequest, options?: RawAxiosRequestConfig) {
        return OrgSettingsApiFp(this.configuration).v2OrgsNameSettingsGet(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an organization\'s settings. Some settings are only used when the organization is on a business plan.  ***Only users with administrative privileges for the organization (owner role) can modify these settings.***  The following settings are only used on a business plan: - `restricted_images` 
     * @summary Update organization settings
     * @param {OrgSettingsApiV2OrgsNameSettingsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgSettingsApi
     */
    public v2OrgsNameSettingsPut(requestParameters: OrgSettingsApiV2OrgsNameSettingsPutRequest, options?: RawAxiosRequestConfig) {
        return OrgSettingsApiFp(this.configuration).v2OrgsNameSettingsPut(requestParameters.name, requestParameters.v2OrgsNameSettingsPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesApi - axios parameter creator
 * @export
 */
export const RepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List repository tags
         * @param {string} namespace 
         * @param {string} repository 
         * @param {number} [page] Page number to get. Defaults to 1.
         * @param {number} [pageSize] Number of items to get per page. Defaults to 10. Max of 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NamespacesNamespaceRepositoriesRepositoryTagsGet: async (namespace: string, repository: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsGet', 'namespace', namespace)
            // verify required parameter 'repository' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsGet', 'repository', repository)
            const localVarPath = `/v2/namespaces/{namespace}/repositories/{repository}/tags`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"repository"}}`, encodeURIComponent(String(repository)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check repository tags
         * @param {string} namespace 
         * @param {string} repository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NamespacesNamespaceRepositoriesRepositoryTagsHead: async (namespace: string, repository: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsHead', 'namespace', namespace)
            // verify required parameter 'repository' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsHead', 'repository', repository)
            const localVarPath = `/v2/namespaces/{namespace}/repositories/{repository}/tags`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"repository"}}`, encodeURIComponent(String(repository)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read repository tag
         * @param {string} namespace 
         * @param {string} repository 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet: async (namespace: string, repository: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet', 'namespace', namespace)
            // verify required parameter 'repository' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet', 'repository', repository)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet', 'tag', tag)
            const localVarPath = `/v2/namespaces/{namespace}/repositories/{repository}/tags/{tag}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"repository"}}`, encodeURIComponent(String(repository)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check repository tag
         * @param {string} namespace 
         * @param {string} repository 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead: async (namespace: string, repository: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead', 'namespace', namespace)
            // verify required parameter 'repository' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead', 'repository', repository)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead', 'tag', tag)
            const localVarPath = `/v2/namespaces/{namespace}/repositories/{repository}/tags/{tag}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"repository"}}`, encodeURIComponent(String(repository)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesApi - functional programming interface
 * @export
 */
export const RepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List repository tags
         * @param {string} namespace 
         * @param {string} repository 
         * @param {number} [page] Page number to get. Defaults to 1.
         * @param {number} [pageSize] Number of items to get per page. Defaults to 10. Max of 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2NamespacesNamespaceRepositoriesRepositoryTagsGet(namespace: string, repository: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2NamespacesNamespaceRepositoriesRepositoryTagsGet(namespace, repository, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.v2NamespacesNamespaceRepositoriesRepositoryTagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check repository tags
         * @param {string} namespace 
         * @param {string} repository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2NamespacesNamespaceRepositoriesRepositoryTagsHead(namespace: string, repository: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2NamespacesNamespaceRepositoriesRepositoryTagsHead(namespace, repository, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.v2NamespacesNamespaceRepositoriesRepositoryTagsHead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read repository tag
         * @param {string} namespace 
         * @param {string} repository 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet(namespace: string, repository: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet(namespace, repository, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check repository tag
         * @param {string} namespace 
         * @param {string} repository 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead(namespace: string, repository: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead(namespace, repository, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RepositoriesApi - factory interface
 * @export
 */
export const RepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary List repository tags
         * @param {RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NamespacesNamespaceRepositoriesRepositoryTagsGet(requestParameters: RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTags> {
            return localVarFp.v2NamespacesNamespaceRepositoriesRepositoryTagsGet(requestParameters.namespace, requestParameters.repository, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check repository tags
         * @param {RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsHeadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NamespacesNamespaceRepositoriesRepositoryTagsHead(requestParameters: RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsHeadRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v2NamespacesNamespaceRepositoriesRepositoryTagsHead(requestParameters.namespace, requestParameters.repository, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read repository tag
         * @param {RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet(requestParameters: RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet(requestParameters.namespace, requestParameters.repository, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check repository tag
         * @param {RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagHeadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead(requestParameters: RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagHeadRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead(requestParameters.namespace, requestParameters.repository, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for v2NamespacesNamespaceRepositoriesRepositoryTagsGet operation in RepositoriesApi.
 * @export
 * @interface RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGetRequest
 */
export interface RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGet
     */
    readonly namespace: string

    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGet
     */
    readonly repository: string

    /**
     * Page number to get. Defaults to 1.
     * @type {number}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGet
     */
    readonly page?: number

    /**
     * Number of items to get per page. Defaults to 10. Max of 100.
     * @type {number}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGet
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v2NamespacesNamespaceRepositoriesRepositoryTagsHead operation in RepositoriesApi.
 * @export
 * @interface RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsHeadRequest
 */
export interface RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsHeadRequest {
    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsHead
     */
    readonly namespace: string

    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsHead
     */
    readonly repository: string
}

/**
 * Request parameters for v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet operation in RepositoriesApi.
 * @export
 * @interface RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagGetRequest
 */
export interface RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagGet
     */
    readonly namespace: string

    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagGet
     */
    readonly repository: string

    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagGet
     */
    readonly tag: string
}

/**
 * Request parameters for v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead operation in RepositoriesApi.
 * @export
 * @interface RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagHeadRequest
 */
export interface RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagHeadRequest {
    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagHead
     */
    readonly namespace: string

    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagHead
     */
    readonly repository: string

    /**
     * 
     * @type {string}
     * @memberof RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagHead
     */
    readonly tag: string
}

/**
 * RepositoriesApi - object-oriented interface
 * @export
 * @class RepositoriesApi
 * @extends {BaseAPI}
 */
export class RepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary List repository tags
     * @param {RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public v2NamespacesNamespaceRepositoriesRepositoryTagsGet(requestParameters: RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).v2NamespacesNamespaceRepositoriesRepositoryTagsGet(requestParameters.namespace, requestParameters.repository, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check repository tags
     * @param {RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsHeadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public v2NamespacesNamespaceRepositoriesRepositoryTagsHead(requestParameters: RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsHeadRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).v2NamespacesNamespaceRepositoriesRepositoryTagsHead(requestParameters.namespace, requestParameters.repository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read repository tag
     * @param {RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet(requestParameters: RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagGetRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).v2NamespacesNamespaceRepositoriesRepositoryTagsTagGet(requestParameters.namespace, requestParameters.repository, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check repository tag
     * @param {RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagHeadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead(requestParameters: RepositoriesApiV2NamespacesNamespaceRepositoriesRepositoryTagsTagHeadRequest, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).v2NamespacesNamespaceRepositoriesRepositoryTagsTagHead(requestParameters.namespace, requestParameters.repository, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScimApi - axios parameter creator
 * @export
 */
export const ScimApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all resource types supported for the SCIM configuration. 
         * @summary List resource types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20ResourceTypesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/scim/2.0/ResourceTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a resource type by name. 
         * @summary Get a resource type
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20ResourceTypesNameGet: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/scim/2.0/ResourceTypes/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all schemas supported for the SCIM configuration. 
         * @summary List schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20SchemasGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/scim/2.0/Schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a schema by ID. 
         * @summary Get a schema
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20SchemasIdGet: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/scim/2.0/Schemas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a service provider config for Docker\'s configuration. 
         * @summary Get service provider config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20ServiceProviderConfigGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/scim/2.0/ServiceProviderConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users, returns paginated users for an organization. Use `startIndex` and `count` query parameters to receive paginated results.  **Sorting:**<br> Sorting lets you specify the order of returned resources by specifying a combination of `sortBy` and `sortOrder` query parameters.  The `sortBy` parameter specifies the attribute whose value will be used to order the returned responses. The `sortOrder` parameter defines the order in which the `sortBy` parameter is applied. Allowed values are \"ascending\" and \"descending\".  **Filtering:**<br> You can request a subset of resources by specifying the `filter` query parameter containing a filter expression. Attribute names and attribute operators used in filters are case insensitive. The filter parameter must contain at least one valid expression. Each expression must contain an attribute name followed by an attribute operator and an optional value.  Supported operators are listed below.  - `eq` equal - `ne` not equal - `co` contains - `sw` starts with - `and` Logical \"and\" - `or` Logical \"or\" - `not` \"Not\" function - `()` Precedence grouping 
         * @summary List users
         * @param {number} [startIndex] 
         * @param {number} [count] 
         * @param {string} [filter] 
         * @param {string} [attributes] Comma delimited list of attributes to limit to in the response.
         * @param {V2Scim20UsersGetSortOrderEnum} [sortOrder] 
         * @param {string} [sortBy] User attribute to sort by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20UsersGet: async (startIndex?: number, count?: number, filter?: string, attributes?: string, sortOrder?: V2Scim20UsersGetSortOrderEnum, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/scim/2.0/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = attributes;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a user by ID. 
         * @summary Get a user
         * @param {string} [id] The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20UsersIdGet: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/scim/2.0/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a user. Use this route to change the user\'s name, activate, and deactivate the user. 
         * @summary Update a user
         * @param {V2Scim20UsersIdPutRequest} v2Scim20UsersIdPutRequest 
         * @param {string} [id] The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20UsersIdPut: async (v2Scim20UsersIdPutRequest: V2Scim20UsersIdPutRequest, id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v2Scim20UsersIdPutRequest' is not null or undefined
            assertParamExists('v2Scim20UsersIdPut', 'v2Scim20UsersIdPutRequest', v2Scim20UsersIdPutRequest)
            const localVarPath = `/v2/scim/2.0/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/scim+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2Scim20UsersIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a user. If the user already exists by email, they are assigned to the organization on the \"company\" team. 
         * @summary Create user
         * @param {V2Scim20UsersPostRequest} v2Scim20UsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20UsersPost: async (v2Scim20UsersPostRequest: V2Scim20UsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v2Scim20UsersPostRequest' is not null or undefined
            assertParamExists('v2Scim20UsersPost', 'v2Scim20UsersPostRequest', v2Scim20UsersPostRequest)
            const localVarPath = `/v2/scim/2.0/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/scim+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2Scim20UsersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScimApi - functional programming interface
 * @export
 */
export const ScimApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScimApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all resource types supported for the SCIM configuration. 
         * @summary List resource types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Scim20ResourceTypesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Scim20ResourceTypesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Scim20ResourceTypesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScimApi.v2Scim20ResourceTypesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a resource type by name. 
         * @summary Get a resource type
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Scim20ResourceTypesNameGet(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScimResourceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Scim20ResourceTypesNameGet(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScimApi.v2Scim20ResourceTypesNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all schemas supported for the SCIM configuration. 
         * @summary List schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Scim20SchemasGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Scim20SchemasGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Scim20SchemasGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScimApi.v2Scim20SchemasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a schema by ID. 
         * @summary Get a schema
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Scim20SchemasIdGet(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScimSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Scim20SchemasIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScimApi.v2Scim20SchemasIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a service provider config for Docker\'s configuration. 
         * @summary Get service provider config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Scim20ServiceProviderConfigGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScimServiceProviderConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Scim20ServiceProviderConfigGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScimApi.v2Scim20ServiceProviderConfigGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List users, returns paginated users for an organization. Use `startIndex` and `count` query parameters to receive paginated results.  **Sorting:**<br> Sorting lets you specify the order of returned resources by specifying a combination of `sortBy` and `sortOrder` query parameters.  The `sortBy` parameter specifies the attribute whose value will be used to order the returned responses. The `sortOrder` parameter defines the order in which the `sortBy` parameter is applied. Allowed values are \"ascending\" and \"descending\".  **Filtering:**<br> You can request a subset of resources by specifying the `filter` query parameter containing a filter expression. Attribute names and attribute operators used in filters are case insensitive. The filter parameter must contain at least one valid expression. Each expression must contain an attribute name followed by an attribute operator and an optional value.  Supported operators are listed below.  - `eq` equal - `ne` not equal - `co` contains - `sw` starts with - `and` Logical \"and\" - `or` Logical \"or\" - `not` \"Not\" function - `()` Precedence grouping 
         * @summary List users
         * @param {number} [startIndex] 
         * @param {number} [count] 
         * @param {string} [filter] 
         * @param {string} [attributes] Comma delimited list of attributes to limit to in the response.
         * @param {V2Scim20UsersGetSortOrderEnum} [sortOrder] 
         * @param {string} [sortBy] User attribute to sort by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Scim20UsersGet(startIndex?: number, count?: number, filter?: string, attributes?: string, sortOrder?: V2Scim20UsersGetSortOrderEnum, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Scim20UsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Scim20UsersGet(startIndex, count, filter, attributes, sortOrder, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScimApi.v2Scim20UsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a user by ID. 
         * @summary Get a user
         * @param {string} [id] The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Scim20UsersIdGet(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScimUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Scim20UsersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScimApi.v2Scim20UsersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a user. Use this route to change the user\'s name, activate, and deactivate the user. 
         * @summary Update a user
         * @param {V2Scim20UsersIdPutRequest} v2Scim20UsersIdPutRequest 
         * @param {string} [id] The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Scim20UsersIdPut(v2Scim20UsersIdPutRequest: V2Scim20UsersIdPutRequest, id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScimUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Scim20UsersIdPut(v2Scim20UsersIdPutRequest, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScimApi.v2Scim20UsersIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a user. If the user already exists by email, they are assigned to the organization on the \"company\" team. 
         * @summary Create user
         * @param {V2Scim20UsersPostRequest} v2Scim20UsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Scim20UsersPost(v2Scim20UsersPostRequest: V2Scim20UsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScimUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Scim20UsersPost(v2Scim20UsersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScimApi.v2Scim20UsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScimApi - factory interface
 * @export
 */
export const ScimApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScimApiFp(configuration)
    return {
        /**
         * Returns all resource types supported for the SCIM configuration. 
         * @summary List resource types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20ResourceTypesGet(options?: RawAxiosRequestConfig): AxiosPromise<V2Scim20ResourceTypesGet200Response> {
            return localVarFp.v2Scim20ResourceTypesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a resource type by name. 
         * @summary Get a resource type
         * @param {ScimApiV2Scim20ResourceTypesNameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20ResourceTypesNameGet(requestParameters: ScimApiV2Scim20ResourceTypesNameGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ScimResourceType> {
            return localVarFp.v2Scim20ResourceTypesNameGet(requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all schemas supported for the SCIM configuration. 
         * @summary List schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20SchemasGet(options?: RawAxiosRequestConfig): AxiosPromise<V2Scim20SchemasGet200Response> {
            return localVarFp.v2Scim20SchemasGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a schema by ID. 
         * @summary Get a schema
         * @param {ScimApiV2Scim20SchemasIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20SchemasIdGet(requestParameters: ScimApiV2Scim20SchemasIdGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ScimSchema> {
            return localVarFp.v2Scim20SchemasIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a service provider config for Docker\'s configuration. 
         * @summary Get service provider config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20ServiceProviderConfigGet(options?: RawAxiosRequestConfig): AxiosPromise<ScimServiceProviderConfig> {
            return localVarFp.v2Scim20ServiceProviderConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List users, returns paginated users for an organization. Use `startIndex` and `count` query parameters to receive paginated results.  **Sorting:**<br> Sorting lets you specify the order of returned resources by specifying a combination of `sortBy` and `sortOrder` query parameters.  The `sortBy` parameter specifies the attribute whose value will be used to order the returned responses. The `sortOrder` parameter defines the order in which the `sortBy` parameter is applied. Allowed values are \"ascending\" and \"descending\".  **Filtering:**<br> You can request a subset of resources by specifying the `filter` query parameter containing a filter expression. Attribute names and attribute operators used in filters are case insensitive. The filter parameter must contain at least one valid expression. Each expression must contain an attribute name followed by an attribute operator and an optional value.  Supported operators are listed below.  - `eq` equal - `ne` not equal - `co` contains - `sw` starts with - `and` Logical \"and\" - `or` Logical \"or\" - `not` \"Not\" function - `()` Precedence grouping 
         * @summary List users
         * @param {ScimApiV2Scim20UsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20UsersGet(requestParameters: ScimApiV2Scim20UsersGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<V2Scim20UsersGet200Response> {
            return localVarFp.v2Scim20UsersGet(requestParameters.startIndex, requestParameters.count, requestParameters.filter, requestParameters.attributes, requestParameters.sortOrder, requestParameters.sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a user by ID. 
         * @summary Get a user
         * @param {ScimApiV2Scim20UsersIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20UsersIdGet(requestParameters: ScimApiV2Scim20UsersIdGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ScimUser> {
            return localVarFp.v2Scim20UsersIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a user. Use this route to change the user\'s name, activate, and deactivate the user. 
         * @summary Update a user
         * @param {ScimApiV2Scim20UsersIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20UsersIdPut(requestParameters: ScimApiV2Scim20UsersIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScimUser> {
            return localVarFp.v2Scim20UsersIdPut(requestParameters.v2Scim20UsersIdPutRequest, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a user. If the user already exists by email, they are assigned to the organization on the \"company\" team. 
         * @summary Create user
         * @param {ScimApiV2Scim20UsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Scim20UsersPost(requestParameters: ScimApiV2Scim20UsersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScimUser> {
            return localVarFp.v2Scim20UsersPost(requestParameters.v2Scim20UsersPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for v2Scim20ResourceTypesNameGet operation in ScimApi.
 * @export
 * @interface ScimApiV2Scim20ResourceTypesNameGetRequest
 */
export interface ScimApiV2Scim20ResourceTypesNameGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ScimApiV2Scim20ResourceTypesNameGet
     */
    readonly name?: string
}

/**
 * Request parameters for v2Scim20SchemasIdGet operation in ScimApi.
 * @export
 * @interface ScimApiV2Scim20SchemasIdGetRequest
 */
export interface ScimApiV2Scim20SchemasIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ScimApiV2Scim20SchemasIdGet
     */
    readonly id?: string
}

/**
 * Request parameters for v2Scim20UsersGet operation in ScimApi.
 * @export
 * @interface ScimApiV2Scim20UsersGetRequest
 */
export interface ScimApiV2Scim20UsersGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ScimApiV2Scim20UsersGet
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ScimApiV2Scim20UsersGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof ScimApiV2Scim20UsersGet
     */
    readonly filter?: string

    /**
     * Comma delimited list of attributes to limit to in the response.
     * @type {string}
     * @memberof ScimApiV2Scim20UsersGet
     */
    readonly attributes?: string

    /**
     * 
     * @type {'ascending' | 'descending'}
     * @memberof ScimApiV2Scim20UsersGet
     */
    readonly sortOrder?: V2Scim20UsersGetSortOrderEnum

    /**
     * User attribute to sort by.
     * @type {string}
     * @memberof ScimApiV2Scim20UsersGet
     */
    readonly sortBy?: string
}

/**
 * Request parameters for v2Scim20UsersIdGet operation in ScimApi.
 * @export
 * @interface ScimApiV2Scim20UsersIdGetRequest
 */
export interface ScimApiV2Scim20UsersIdGetRequest {
    /**
     * The user ID.
     * @type {string}
     * @memberof ScimApiV2Scim20UsersIdGet
     */
    readonly id?: string
}

/**
 * Request parameters for v2Scim20UsersIdPut operation in ScimApi.
 * @export
 * @interface ScimApiV2Scim20UsersIdPutRequest
 */
export interface ScimApiV2Scim20UsersIdPutRequest {
    /**
     * 
     * @type {V2Scim20UsersIdPutRequest}
     * @memberof ScimApiV2Scim20UsersIdPut
     */
    readonly v2Scim20UsersIdPutRequest: V2Scim20UsersIdPutRequest

    /**
     * The user ID.
     * @type {string}
     * @memberof ScimApiV2Scim20UsersIdPut
     */
    readonly id?: string
}

/**
 * Request parameters for v2Scim20UsersPost operation in ScimApi.
 * @export
 * @interface ScimApiV2Scim20UsersPostRequest
 */
export interface ScimApiV2Scim20UsersPostRequest {
    /**
     * 
     * @type {V2Scim20UsersPostRequest}
     * @memberof ScimApiV2Scim20UsersPost
     */
    readonly v2Scim20UsersPostRequest: V2Scim20UsersPostRequest
}

/**
 * ScimApi - object-oriented interface
 * @export
 * @class ScimApi
 * @extends {BaseAPI}
 */
export class ScimApi extends BaseAPI {
    /**
     * Returns all resource types supported for the SCIM configuration. 
     * @summary List resource types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScimApi
     */
    public v2Scim20ResourceTypesGet(options?: RawAxiosRequestConfig) {
        return ScimApiFp(this.configuration).v2Scim20ResourceTypesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a resource type by name. 
     * @summary Get a resource type
     * @param {ScimApiV2Scim20ResourceTypesNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScimApi
     */
    public v2Scim20ResourceTypesNameGet(requestParameters: ScimApiV2Scim20ResourceTypesNameGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ScimApiFp(this.configuration).v2Scim20ResourceTypesNameGet(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all schemas supported for the SCIM configuration. 
     * @summary List schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScimApi
     */
    public v2Scim20SchemasGet(options?: RawAxiosRequestConfig) {
        return ScimApiFp(this.configuration).v2Scim20SchemasGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a schema by ID. 
     * @summary Get a schema
     * @param {ScimApiV2Scim20SchemasIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScimApi
     */
    public v2Scim20SchemasIdGet(requestParameters: ScimApiV2Scim20SchemasIdGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ScimApiFp(this.configuration).v2Scim20SchemasIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a service provider config for Docker\'s configuration. 
     * @summary Get service provider config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScimApi
     */
    public v2Scim20ServiceProviderConfigGet(options?: RawAxiosRequestConfig) {
        return ScimApiFp(this.configuration).v2Scim20ServiceProviderConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List users, returns paginated users for an organization. Use `startIndex` and `count` query parameters to receive paginated results.  **Sorting:**<br> Sorting lets you specify the order of returned resources by specifying a combination of `sortBy` and `sortOrder` query parameters.  The `sortBy` parameter specifies the attribute whose value will be used to order the returned responses. The `sortOrder` parameter defines the order in which the `sortBy` parameter is applied. Allowed values are \"ascending\" and \"descending\".  **Filtering:**<br> You can request a subset of resources by specifying the `filter` query parameter containing a filter expression. Attribute names and attribute operators used in filters are case insensitive. The filter parameter must contain at least one valid expression. Each expression must contain an attribute name followed by an attribute operator and an optional value.  Supported operators are listed below.  - `eq` equal - `ne` not equal - `co` contains - `sw` starts with - `and` Logical \"and\" - `or` Logical \"or\" - `not` \"Not\" function - `()` Precedence grouping 
     * @summary List users
     * @param {ScimApiV2Scim20UsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScimApi
     */
    public v2Scim20UsersGet(requestParameters: ScimApiV2Scim20UsersGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ScimApiFp(this.configuration).v2Scim20UsersGet(requestParameters.startIndex, requestParameters.count, requestParameters.filter, requestParameters.attributes, requestParameters.sortOrder, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a user by ID. 
     * @summary Get a user
     * @param {ScimApiV2Scim20UsersIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScimApi
     */
    public v2Scim20UsersIdGet(requestParameters: ScimApiV2Scim20UsersIdGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ScimApiFp(this.configuration).v2Scim20UsersIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a user. Use this route to change the user\'s name, activate, and deactivate the user. 
     * @summary Update a user
     * @param {ScimApiV2Scim20UsersIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScimApi
     */
    public v2Scim20UsersIdPut(requestParameters: ScimApiV2Scim20UsersIdPutRequest, options?: RawAxiosRequestConfig) {
        return ScimApiFp(this.configuration).v2Scim20UsersIdPut(requestParameters.v2Scim20UsersIdPutRequest, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a user. If the user already exists by email, they are assigned to the organization on the \"company\" team. 
     * @summary Create user
     * @param {ScimApiV2Scim20UsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScimApi
     */
    public v2Scim20UsersPost(requestParameters: ScimApiV2Scim20UsersPostRequest, options?: RawAxiosRequestConfig) {
        return ScimApiFp(this.configuration).v2Scim20UsersPost(requestParameters.v2Scim20UsersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const V2Scim20UsersGetSortOrderEnum = {
    Ascending: 'ascending',
    Descending: 'descending'
} as const;
export type V2Scim20UsersGetSortOrderEnum = typeof V2Scim20UsersGetSortOrderEnum[keyof typeof V2Scim20UsersGetSortOrderEnum];


